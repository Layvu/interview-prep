### Отличие var, let, const
**var**:
- Функциональная область видимости. Блоки {} (например, в if, for, или просто {}) не создают новую область видимости
- Повторное объявление разрешено в той же области видимости
- Переприсваивание разрешено
- Поднятие (Hoisting): переменные поднимаются (hoisted) в начало функции или глобальной области, но инициализируются как undefined до присваивания
**let**:
- Блочная область видимости (ограничена {})
- Повторное объявление запрещено в той же области видимости
- Переприсваивание разрешено
- Поднятие (Hoisting): Переменные поднимаются, но не инициализируются (в TDZ, temporal dead zone)
**const**: 
- как let, но переприсваивание запрещено

### Какие есть виды функций? Их главные отличия

**База:**
Function Declaration - Можно вызвать до объявления функции из-за всплытия
Function Expression - Нельзя вызвать переменную до инициации (с let/const)
Arrow - Нет собственного this, Hoisting как у функционального выражения, нет псевдомассива **arguments!**

**А также:**
IIFE - Выполняется сразу после объявления
Метод объекта - obj.method() → this = obj
Constructor Function - Используется с new для создания объектов, this ссылается на новый экземпляр
Генераторы - Используют yield для возврата значений по одному
async - Всегда возвращают Promise

1. По способу объявления
a) Функциональное объявление (**Function Declaration**)
```JS
console.log(myFn()); // Работает из-за hoisting
function myFn() { return 'Hello'; } // Hello
```
- Hoisting: Полностью поднимается
- Область видимости: Функциональная или глобальная
- Контекст this: Зависит от способа вызова

b) Функциональное выражение (**Function Expression**)
```JS
// console.log(myFn()); // ReferenceError, если вызывать до объявления с let/const
const myFn = function() { return 'Hello'; };
console.log(myFn()); // Hello
```
- Hoisting: зависит от переменной (с var — как undefined, с let/const — TDZ)
- Область видимости: зависит от переменной
- Контекст this: зависит от вызова, как у декларации

c) Стрелочная функция (**Arrow Function**, ES6)
```JS
const arrowFn = () => {
console.log(arguments); // ReferenceError в строгом режиме
};

// Function Declaration:
function regularFn() {
    console.log(arguments); // Псевдомассив аргументов
    console.log(arguments[0], arguments[1]); // Доступ по индексам
}
regularFn(1, 2, 3); // Arguments [1, 2, 3], 1, 2
```
- Захватывает this из лексического контекста (родительской области)
- Нет **arguments**: Не имеет объекта arguments, используйте rest-параметры (...args).
- Hoisting: Как у функционального выражения (зависит от var/let/const).
- Не подходит для конструкторов: Нельзя использовать с new.

Если попытаться обратиться к **arguments** в стрелочной функции, JS либо:
- В нестрогом режиме: Использует arguments из ближайшей внешней обычной функции
- В строгом режиме или без внешней функции: Вызовет ошибку (ReferenceError: arguments is not defined).

d) Немедленно вызываемая функциональная выражение (**IIFE**)
```JS
(function() { console.log('IIFE'); })();
```
- Выполняется сразу после объявления.
- Используется для создания изолированной области видимости

e) **Метод объекта**
```JS
const obj = { method() { return 'Method'; } };
```
- obj.method() → this = obj

f) Конструктор (**Constructor Function**)
```JS
function Person(name) { this.name = name; }
const person = new Person('Alice');
console.log(person.name); // Alice
```
- Используется с **new** для создания объектов, this ссылается на новый экземпляр

2. По назначению
a) Обычные функции

b) Генераторы (**Generator Functions**, ES6)
```JS
function* gen() { yield 1; yield 2; }
const iter = gen();
console.log(iter.next().value); // 1
console.log(iter.next().value); // 2
```
Файл: js\generatorFunc.js

- this: как у обычных функций
- Вызов function* не выполняет функцию сразу, а возвращает итератор
- Итератор имеет метод .next(), который запускает или возобновляет выполнение до следующего yield или конца функции

c) Асинхронные функции (**Async Functions**, ES8)
```JS
async function fetchData() {
    const data = await Promise.resolve('Data');
    return data;
}
fetchData().then(console.log); // Data
```
- Всегда возвращают Promise
- this: как у обычных функций

### Что использовать вместо arguments в стрелочных функциях?
rest-параметры

```JS
const arrowFn = (...args) => {
    console.log(args); // Настоящий массив
    console.log(args[0], args[1]); // Доступ по индексам
    console.log(args.map(x => x * 2)); // Методы массива
};
arrowFn(1, 2, 3); // [1, 2, 3], 1, 2, [2, 4, 6]
```