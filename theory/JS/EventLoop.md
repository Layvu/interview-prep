### Как работает EventLoop?

task: js\eventLoop.js

**Event Loop** (цикл событий) - это механизм JavaScript для обработки асинхронных операций в однопоточном окружении

**Состоит из:**
**Стек вызова** - хранит и выполняет синхронные операции
**Web API** - внешние механизмы (в браузере или Node.js), которые обрабатывают асинхронные операции (например, setTimeout, fetch, события DOM), а коллбэки возвращают в очереди
**Очереди задач** - выполняются колбеки. Сначала микро задачи, после макро задача и заново

**Схема** приоритетов выполнения:
1. Сначала выполняется текущий синхронный код
2. Асинхронные операции передаются в Web API, которые отправляют коллбэки в очереди задач
3. Затем выполняются все микрозадачи в очереди Microtask queue до тех пор, пока очередь не станет пустой
4. После этого выполняется **одна** следующая макрозадача из очереди Macrotask queue
5. Повторяет цикл

**Микрозадачи:** выполняются сразу после завершения текущей синхронной задачи, но перед началом следующей макрозадачи
**Примеры**: Промисы (`Promise`, `async/await`, `MutationObserver`, `queueMicrotask)

**Макрозадачи:** выполняются после завершения текущей синхронной задачи
**Примеры**: Синхронный код, таймеры (`setTimeout`, `setInterval`), события пользовательского интерфейса (браузерное взаимодействие, например, `клики мыши`), сетевые запросы (например, `fetch` или XMLHttpRequest)

**Цель** - циклическое выполнение задач, которые делятся на две категории:
1. Синхронные задачи - выполняются немедленно
2. Асинхронные задачи - добавляются в очередь и выполняются позже
#### В микро и макротаски мы записываем именно колбеки
Очень важно понимать это для решения задач 

```JS
setTimeout(function timeout() {
    console.log('Таймаут');
}, 0);

let p = new Promise(function (resolve, reject) {
    console.log('Создание промиса');
    resolve();
});

p.then(function () {
    console.log('Обработка промиса');
});

console.log('Конец скрипта');

// Создание промиса
// Конец скрипта
// Обработка промиса
// Таймаут
```

resolve() разрешает Promise немедленно. Это означает, что все обработчики, зарегистрированные через p.then, будут добавлены в Microtask Queue для выполнения после синхронного кода.

Т.е. по сути мы идём сверху вниз, setTimeout изначально ждёт время, дальше смотрим let p, синхронно обрабатываем создание промиса и резолвим его. Далее синхронно обрабатываем p.then, не ждём, т.к. зарезолвлен, закидываем коллбэк из .then в Microtask Queue. Далее синхронный код вывода в консоль 'Конец скрипта'. Далее разбираем микротаски, выводим 'Обработка промиса' и далее макротаски - 'Таймаут'