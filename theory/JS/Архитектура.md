## Базовые понятия ООП

https://www.youtube.com/watch?v=Z7V4ZtiF8Uc

ООП реализуется через классы (с ES6) и прототипы
В самом JS (ES5) нет классов - это всё функции, синтаксический сахар. Всё работает на свойстве prototype (позволяет передать инстансу атрибуты и методы) и __ proto __ (ссылка на родителя)
 
Основные принципы:
1. **Инкапсуляция:** сокрытие внутренней реализации объекта и предоставление доступа к данным только через публичные методы (интерфейс)
- Ограничение видимости атрибутов и методов в контексте конкретного объекта
- Защищает данные от некорректного изменения

Реализация в JS: используются закрытые поля (с # в классах с ES2022) или замыкания:
```JS
class Counter {
    #count = 0; // Приватное поле
    increment() { this.#count++; }
    getCount() { return this.#count; }
}
const counter = new Counter();
counter.increment();
console.log(counter.getCount()); // 1
// console.log(counter.#count); // Ошибка: приватное поле
```

Обозначения доступности для атрибутов и методов классах:
```JS
_card - protected (для поддержания стиля)
__card - private (для поддержания стиля)
#card - private (установит доступ)
```

Также используем **get()** и **set()** для инкапсуляции. И ключевое слово **static** для обращения через class (Person.Smth)

2. **Наследование:** механизм, позволяющий классу (подклассу) наследовать свойства и методы другого класса (суперкласса)
- Позволяет переиспользовать код, строить иерархии

Реализация в JS:  используется ключевое слово **extends** и **super** для вызова конструктора родителя. Работает через **прототипное наследование**:

```JS
class Animal {
    constructor(name) { this.name = name; }
    speak() { console.log(`${this.name} издаёт звук`); }
}
class Dog extends Animal {
    speak() { console.log(`${this.name} гавкает`); }
}
const dog = new Dog('Шарик');
dog.speak(); // Шарик гавкает
```

3. **Полиморфизм:** способность объектов разных классов обрабатывать одинаковые методы по-разному (переопределение методов) или работать с объектами разных типов через общий интерфейс
- В зависимости от класса метод исполняется по разному
- **Пример**: есть класс круг, квадрат и треугольник. У всех есть метод draw, но при этом в зависимости от класса рисунок будет отличаться
- Позволяет работать с разными типами объектов единообразно

Реализация в JS: через переопределение методов в подклассах или использование общих интерфейсов:
```JS
class Cat extends Animal {
    speak() { console.log(`${this.name} мяукает`); }
}
const animals = [new Dog('Шарик'), new Cat('Мурка')];
animals.forEach(animal => animal.speak());
// Шарик гавкает
// Мурка мяукает
```

3. **Абстракция:** выделение ключевых характеристик объекта без деталей реализации
- Это базовый класс, интерфейс, который описывает ключевые характеристики
- Упрощает взаимодействие с объектом, скрывая сложность реализации

Реализация: JS не имеет встроенных абстрактных классов, но абстракцию можно имитировать, создавая базовые классы или интерфейсы
```JS
class Shape {
    area() { throw new Error('Метод area() должен быть реализован'); }
}
class Circle extends Shape {
    constructor(radius) { super(); this.radius = radius; }
    area() { return Math.PI * this.radius ** 2; }
}
const circle = new Circle(5);
console.log(circle.area()); // ~78.54
```


**Класс** - шаблон для создания объектов, определяющий их свойства (данные) и методы (поведение). В JS классы - это синтаксический сахар над прототипами.
**Объект** - экземпляр класса
**Конструктор** - метод, вызываемый при создании объекта через new, для инициализации его свойств
**Прототипы** - JS использует прототипное наследование. Каждый объект имеет прототип, от которого он наследует свойства и методы.
**super** - ссылка на родителя. Например, можно вызвать метод родителя через super.smth()
### Процедурный стиль
По сути то, как мы обычно пишем код, по порядку
### Функциональный стиль
Фокус на использовании функций в качестве блоков кода
В отличие от императивного программирования, программист не диктует порядок исполнения, а **описывает правила** взаимодействия и взаимосвязи между компонентами. Программа, в свою очередь, сама определяет оптимальный способ достижения результата, основываясь на этих правилах.


## Какие существуют паттерны проектирования?

- **Порождающие паттерны** (Фабричный метод, Абстрактная фабрика, Singleton, Builder, Prototype): Решают задачи создания объектов
- **Структурные паттерны** (Adapter, Decorator, Facade, Composite, Proxy): Определяют отношения между классами
- **Поведенческие паттерны** (Observer, Стратегия, Command, Template Method, Iterator): Описывают взаимодействие объектов

Фабричный метод - определяет интерфейс для создания новых классов
Абстрактная фабрика - создаёт семейства связанных классов
Singleton - создание единственного экземпляра класса
Builder - разделяет создание сложного объекта, позволяя пошагово конструировать объект
Prototype - создаёт новые объекты путём копирования существующего объекта (прототипа)

### Подробно:

1. **Порождающие паттерны**: решают задачи **создания** объектов

a) **Фабричный метод** (Factory Method):
   - Определяет интерфейс для создания объектов, позволяя подклассам решать, какой класс создавать

     ```javascript
     class Car {
         drive() { console.log('Автомобиль едет'); }
     }
     class Truck {
         drive() { console.log('Грузовик едет'); }
     }
     class VehicleFactory {
         createVehicle(type) {
             if (type === 'car') return new Car();
             if (type === 'truck') return new Truck();
             throw new Error('Неизвестный тип');
         }
     }
     const factory = new VehicleFactory();
     const car = factory.createVehicle('car');
     car.drive(); // Автомобиль едет
     ```

b) **Абстрактная фабрика** (Abstract Factory):
   - Создаёт семейства связанных объектов без указания их конкретных классов

     ```javascript
     class SportCar { drive() { console.log('Спорткар едет'); } }
     class SportBike { ride() { console.log('Спортбайк едет'); } }
     class FamilyCar { drive() { console.log('Семейный авто едет'); } }
     class FamilyBike { ride() { console.log('Семейный байк едет'); } }
     class SportFactory {
         createCar() { return new SportCar(); }
         createBike() { return new SportBike(); }
     }
     class FamilyFactory {
         createCar() { return new FamilyCar(); }
         createBike() { return new FamilyBike(); }
     }
     const sportFactory = new SportFactory();
     sportFactory.createCar().drive(); // Спорткар едет
     ```

c) Одиночка (**Singleton**):
   - Гарантирует, что класс имеет только один экземпляр, и предоставляет глобальную точку доступа.
   - Для управления единственным экземпляром ресурса (например, логгер, подключение к БД)

     ```javascript
     class Singleton {
         constructor() {
             if (Singleton.instance) return Singleton.instance;
             Singleton.instance = this;
         }
     }
     const s1 = new Singleton();
     const s2 = new Singleton();
     console.log(s1 === s2); // true
     ```

d) Строитель (**Builder**):
   - Разделяет создание сложного объекта, позволяя пошагово конструировать объект
   - Упрощает создание объектов с множеством параметров
   
     ```javascript
     class CarBuilder {
         constructor() { this.car = {}; }
         setEngine(engine) { this.car.engine = engine; return this; }
         setWheels(wheels) { this.car.wheels = wheels; return this; }
         build() { return this.car; }
     }
     const car = new CarBuilder().setEngine('V8').setWheels(4).build();
     console.log(car); // { engine: 'V8', wheels: 4 }
     ```

e) Прототип (**Prototype**):
   - Создаёт новые объекты путём копирования существующего объекта (прототипа)
   - Экономит ресурсы при создании похожих объектов

     ```javascript
     const prototype = { name: 'Car', clone() { return Object.create(this); } };
     const newCar = prototype.clone();
     newCar.name = 'Truck';
     console.log(newCar.name, prototype.name); // Truck, Car
     ```

2. **Структурные паттерны:** описывают, как **организовать** объекты и классы в более крупные структуры

a) Адаптер (**Adapter**):
   - Преобразует интерфейс одного класса в интерфейс, ожидаемый клиентом
   - Позволяет несовместимым объектам работать вместе
   
     ```javascript
     class OldSystem { oldRequest() { return 'Старый формат'; } }
     class NewSystem { newRequest() { return 'Новый формат'; } }
     class Adapter {
         constructor(oldSystem) { this.oldSystem = oldSystem; }
         newRequest() { return this.oldSystem.oldRequest().toUpperCase(); }
     }
     const adapter = new Adapter(new OldSystem());
     console.log(adapter.newRequest()); // СТАРЫЙ ФОРМАТ
     ```

b) Декоратор (**Decorator**):
   - Расширяет функциональность без изменения исходного класса

     ```javascript
     class Coffee { cost() { return 5; } }
     class MilkDecorator {
         constructor(coffee) { this.coffee = coffee; }
         cost() { return this.coffee.cost() + 2; }
     }
     const coffee = new MilkDecorator(new Coffee());
     console.log(coffee.cost()); // 7
     ```

c) Фасад (**Facade**):
   - Предоставляет упрощённый интерфейс к сложной подсистеме
   - Скрывает сложность, упрощает использование
   
     ```javascript
     class Subsystem1 { operation1() { return 'Subsystem1'; } }
     class Subsystem2 { operation2() { return 'Subsystem2'; } }
     class Facade {
         constructor() { this.sub1 = new Subsystem1(); this.sub2 = new Subsystem2(); }
         operation() { return `${this.sub1.operation1()} + ${this.sub2.operation2()}`; }
     }
     const facade = new Facade();
     console.log(facade.operation()); // Subsystem1 + Subsystem2
     ```

d) Компоновщик (**Composite**):
   - Объединяет объекты в древовидные структуры для работы с ними как с единым объектом
   - Упрощает работу с иерархиями

     ```javascript
     class Component {
         operation() {}
     }
     class Leaf extends Component {
         operation() { console.log('Leaf'); }
     }
     class Composite extends Component {
         constructor() { super(); this.children = []; }
         add(child) { this.children.push(child); }
         operation() { this.children.forEach(child => child.operation()); }
     }
     const composite = new Composite();
     composite.add(new Leaf());
     composite.operation(); // Leaf
     ```

e) Заместитель (**Proxy**):
   - Контролирует доступ к объекту, добавляя дополнительную логику
   - Для ленивой загрузки, логирования, контроля доступа
   
     ```javascript
     class RealSubject { request() { return 'Реальный запрос'; } }
     class Proxy {
         constructor() { this.subject = new RealSubject(); }
         request() { console.log('Логирование'); return this.subject.request(); }
     }
     const proxy = new Proxy();
     console.log(proxy.request()); // Логирование, Реальный запрос
     ```

3. **Поведенческие паттерны**
Управляют **взаимодействием** и коммуникацией между объектами

a) Наблюдатель (**Observer**):
   - Определяет зависимость "один ко многим", где изменение одного объекта уведомляет всех зависимых
   - Для реализации событийной модели
   
     ```javascript
     class Subject {
         constructor() { this.observers = []; }
         subscribe(observer) { this.observers.push(observer); }
         notify(data) { this.observers.forEach(obs => obs.update(data)); }
     }
     class Observer {
         update(data) { console.log(`Получено: ${data}`); }
     }
     const subject = new Subject();
     subject.subscribe(new Observer());
     subject.notify('Сообщение'); // Получено: Сообщение
     ```

b) Стратегия (**Strategy**):
   - Позволяет выбирать алгоритм поведения во время выполнения
   - Замена алгоритма основного класса без изменения кода
   
     ```javascript
     class Context {
         constructor(strategy) { this.strategy = strategy; }
         execute() { return this.strategy.execute(); }
     }
     class Strategy1 { execute() { return 'Стратегия 1'; } }
     class Strategy2 { execute() { return 'Стратегия 2'; } }
     const context = new Context(new Strategy1());
     console.log(context.execute()); // Стратегия 1
     ```

с) Команда (**Command**):
   - Инкапсулирует запрос в виде объекта, позволяя передавать его как параметр
   - Для реализации отмены операций, очередей команд
   
     ```javascript
     class Command {
         execute() {}
     }
     class LightOnCommand extends Command {
         constructor(light) { super(); this.light = light; }
         execute() { this.light.on(); }
     }
     class Light { on() { console.log('Свет включён'); } }
     const light = new Light();
     const command = new LightOnCommand(light);
     command.execute(); // Свет включён
     ```

d) Шаблонный метод (**Template Method**):
   - Определяет общий алгоритм, позволяя подклассам переопределять отдельные шаги
   - Для повторного использования общей структуры

     ```javascript
     class Beverage {
         prepare() {
             this.boilWater();
             this.addIngredient();
         }
         boilWater() { console.log('Кипятим воду'); }
         addIngredient() {}
     }
     class Coffee extends Beverage {
         addIngredient() { console.log('Добавляем кофе'); }
     }
     const coffee = new Coffee();
     coffee.prepare(); // Кипятим воду, Добавляем кофе
     ```

e) Итератор (**Iterator**):
   - Предоставляет способ последовательного доступа к элементам коллекции
   - Упрощает перебор сложных структур

     ```javascript
     class Iterator {
         constructor(items) { this.items = items; this.index = 0; }
         next() {
             return this.index < this.items.length
                 ? { value: this.items[this.index++], done: false }
                 : { done: true };
         }
     }
     const iter = new Iterator([1, 2, 3]);
     console.log(iter.next().value); // 1
     console.log(iter.next().value); // 2
     ```


### Группы паттернов, для чего используются

Паттерны проектирования делятся на три группы: **порождающие**, **структурные** и **поведенческие**. Каждая группа решает определённый класс задач в проектировании программного обеспечения. Ниже я объясню, **для чего** используется каждая группа, кратко и профессионально, с акцентом на их назначение и примеры в контексте JavaScript.

1. **Порождающие паттерны**
Решают задачи, связанные с **созданием объектов**, упрощая их инициализацию, управление и масштабирование


**Примеры и их задачи**:
- **Фабричный метод**: Делегирует создание объектов подклассам, чтобы поддерживать разные типы объектов (например, создание разных видов UI-компонентов).
  ```javascript
  class ButtonFactory {
      createButton(type) {
          if (type === 'primary') return { render: () => console.log('Primary Button') };
          if (type === 'secondary') return { render: () => console.log('Secondary Button') };
      }
  }
  ```
- **Одиночка (Singleton)**: Гарантирует единственный экземпляр объекта (например, для логгера или соединения с БД).
  ```javascript
  class Logger {
      constructor() { if (Logger.instance) return Logger.instance; Logger.instance = this; }
      log(message) { console.log(message); }
  }
  ```
- **Строитель (Builder)**: Пошагово создаёт сложные объекты (например, конфигурация HTTP-запроса).
  ```javascript
  class RequestBuilder {
      constructor() { this.request = { headers: {}, body: {} }; }
      setHeader(key, value) { this.request.headers[key] = value; return this; }
      build() { return this.request; }
  }
  ```

2. **Структурные паттерны**
Управляют **составом (структурой) объектов и их связями**, определяя, как объекты и классы объединяются в более крупные структуры

Используются когда нужно организовать сложные структуры, обеспечить совместимость или упростить взаимодействие между компонентами

**Примеры и их задачи**:
- **Адаптер**: Делает несовместимые интерфейсы совместимыми (например, адаптация старого API к новому).
  ```javascript
  class OldAPI { oldRequest() { return { data: 'old' }; } }
  class Adapter {
      constructor(oldAPI) { this.oldAPI = oldAPI; }
      request() { return this.oldAPI.oldRequest().data.toUpperCase(); }
  }
  ```
- **Декоратор**: Динамически добавляет функциональность объекту (например, добавление логирования к функции).
  ```javascript
  class LoggerDecorator {
      constructor(func) { this.func = func; }
      call(...args) { console.log('Logging...'); return this.func(...args); }
  }
  const decorated = new LoggerDecorator((x) => x * 2).call(5); // Logging..., 10
  ```
- **Фасад**: Предоставляет упрощённый интерфейс к сложной подсистеме (например, упрощение работы с библиотекой)
- **Proxy**

3. Поведенческие паттерны
Управляют **взаимодействием и коммуникацией** между объектами, определяя, как они обмениваются данными и выполняют задачи

Используется, когда нужно управлять взаимодействием объектов, реализовать события, разделить логику или сделать поведение переключаемым

**Примеры и их задачи**:
- **Наблюдатель (Observer)**: Реализует событийную модель, где объекты уведомляются об изменениях (например, подписка на события

- **Стратегия**: Позволяет менять алгоритм на лету (например, выбор способа сортировки).
  ```javascript
  class Sorter {
      constructor(strategy) { this.strategy = strategy; }
      sort(data) { return this.strategy(data); }
  }
  const sorter = new Sorter(arr => arr.sort((a, b) => a - b));
  console.log(sorter.sort([3, 1, 2])); // [1, 2, 3]
  ```

- **Команда**: Инкапсулирует запрос как объект (например, для реализации отмены операций).
  ```javascript
  class Command {
      constructor(action) { this.action = action; }
      execute() { this.action(); }
  }
  const cmd = new Command(() => console.log('Action'));
  cmd.execute(); // Action
  ```

## SOLID

1. **Single Responsibility** Principle - один класс/компонент - одна задача
Пример: разделяем логику, API и рендеринг

2. **Open/Closed** Principle - классы должны быть **открыты для расширения**, но **закрыты для модификации**. Новое поведение добавляется через наследование или композицию, а не изменение существующего кода.
Пример: есть базовый Button, создаём новые типы через композицию

3. **Liskov Substitution** Principle - замена базового класса на класс‑наследник не должна вызывать проблем
Пример: InputComponent может заменить EmailInput

4. **Interface Segregation** Principle - не зависеть от интерфейсов, функционал которых не используется
Пример: компоненты получают только те пропсы, которые им нужны

5. **Dependency Inversion** Principle - модули высокого уровня не должны зависеть от модулей низкого уровня. Оба **должны зависеть от абстракций**. Абстракции не должны зависеть от деталей реализации