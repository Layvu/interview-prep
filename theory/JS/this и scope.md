### Чему равен this?

**this** - это лексический контекст

У **не стрелочной** и не связанной (bound) функции значение `this` зависит от обстоятельств, в которых она была **вызвана**

1. Глобальный контекст: window/global (или undefined в строгом режиме)
2. Внутри функции: если функция вызывается без привязки, this ссылается на глобальный объект
3. Метод объекта: сам объект
4. Конструктор: новый экземпляр
5. **Стрелочная функция**: не имеют собственного this, захватывают this из лексического контекста (родительской области). Значение `this` в стрелочной функции определяется исключительно тем, где (в каком лексическом контексте) она была **создана**
6. События в DOM: ссылается на элемент, вызвавший событие. В стрелочной функции this берётся из внешнего контекста
7. Явная привязка
- **`call`** вызывает функцию с указанным контекстом **`this`** и отдельными аргументами
- **`apply`** аналогичен **`call`**, но принимает аргументы в виде массива
- **`bind`** создаёт новую функцию с предустановленным контекстом **`this`** и аргументами, если они были предоставлены, но не вызывает её немедленно

Вызов `func.call(context, a, b...)` – то же, что обычный вызов `func(a, b...)`, но с явно указанным `this(=context)`.
```JS
func.call(context, arg1, arg2);
func.apply(context, [arg1, arg2]);

const boundFunction = func.bind(context, arg1, arg2, ...)
```

Пример с собеседований:
```JS
const obj = { 
  test: function(){
    (function(){
      console.log(this);
    })();
  }
}

obj.test();

// window/global | undefined
```

Интересный момент:
Если внешняя функция - метод объекта, this внешней функции будет указывать на объект, но это **не передаётся автоматически** во внутреннюю обычную функцию, если она вызывается без привязки:
```JS
const obj = {
    outer: function() {
        function inner() {
            console.log(this);
        }
        inner();
    }
};
obj.outer(); // В нестрогом режиме: window/global, в строгом: undefined
```

Функция в объекте - this на объект
Стрелочная функция внутри обычной - контекст обычной (захватывает this из лексического контекста)
Стрелочная функция внутри стрелочной - у внутренней будет контекст внешней

Тут внешняя стрелочная функция outer захватывает this из глобального контекста (или контекста, где определён объект obj), так как она не является обычным методом и не привязана к obj:
```JS
const obj = {
    name: 'Alice',
    outer: () => {
        const innerArrow = () => {
            console.log(this); // window/global (или undefined в 'use strict')
        };
        innerArrow();
    }
};
obj.outer();
```

Ещё раз. Обычная функция, вызванная без контекста, будет иметь this равный глобальному объекту
```JS
const obj = {
    name: 'Alice',
    outer: function() {
        const arrow = () => {
            function inner() {
                console.log(this);
            };
            inner(); // можно привязать с помощью call(this), тогда получим Alice
        };
        arrow();
    }
};
obj.outer(); // В нестрогом режиме: window/global, в строгом: undefined
```

### У всех функций есть контекст? 
Стрелочные функции не имеют собственного this, они используют this из внешней лексической области
## Область видимости не равна this

Важно, что область видимости (scope) и контекст this могут отличаться:

```JS
const obj = {
    name: 'Alice',
    outer: function() {
        let outerVar = 'Внешняя';
        function inner() {
            console.log(this.name, outerVar); // this — window/global/undefined
        };
        inner();
    }
};
obj.outer(); // Выведет: undefined Внешняя (или window.name Внешняя)
```

**Лексическая область видимости** - фиксируется на этапе **объявления** функции
Когда функция объявлена внутри другой, она получает доступ к переменным внешней функции через замыкание. Замыкание сохраняет ссылку на лексическое окружение внешней функции, включая все её переменные

**Контекст this обычной функции** - зависит от **способа вызова** функции (с заданным контекстом или нет), а не от её лексической области видимости. А вот **стрелочная функция** как раз захватывает this из лексического контекста, ведь у неё this определяется в момент создания

### Что такое область видимости?

**Область видимости** (scope) - контекст, в котором переменные и функции доступны для использования

- Определяет, где переменная или функция **доступна** в коде
- JS использует **лексическую** область видимости (lexical scoping), где доступность определяется местом объявления в коде

**Типы:**
- **Глобальная**
- **Функциональная** (в функциях)
- **Блочная** (внутри {} с let/const)
- **Модульная** (в ES-модулях)

**Замыкание:** функция, которая "запоминает" переменные из своей внешней области видимости