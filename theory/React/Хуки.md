### Разница между useEffect и useEffectLayout

**useEffect:** **асинхронный** хук для выполнения побочных эффектов **после** рендеринга компонента в DOM
- Для эффектов, которые не влияют на визуальный рендеринг (например, загрузка данных, аналитика, подписки)
- Выполняется после отрисовки, не блокирует рендеринг
- Может вызывать кратковременные несоответствия UI, если эффект изменяет DOM после рендера

**useLayoutEffect:** **синхронный** хук для выполнения побочных эффектов **после** обновления виртуального DOM, но **до** фазы отрисовки в браузере
- Для эффектов, которые влияют на визуальный рендеринг
- **Предотвращает "мерцание"** UI
- Блокирует рендеринг до завершения эффекта, что может **замедлить UI**

### Почему нельзя вызывать хуки за пределами react компонента?

React использует **строгий порядок вызовов** хуков для управления их состояниями. Вызов хука вне компонента нарушает этот порядок, что приводит к ошибке **Invalid hook call**

Хуки зависят от жизненного цикла компонента и его состояния

React требует, чтобы хуки вызывались:
- **На верхнем уровне** - не в циклах, условиях или вложенных функциях
- **Только внутри** функциональных компонентов или пользовательских хуков
- Нарушение вызывает ошибку **Invalid hook call**

Если порядок вызовов хуков меняется (например, хук вызывается в условии), React не сможет правильно сопоставить состояния, что приведёт к ошибке или непредсказуемому поведению.

### Как хук связывается с компонентом? Почему состояния не перемешиваются?

За счёт Fiber архитектуры, каждый компонент в React представлен узлом в дереве рендеринга. Этот узел хранит информацию о компоненте, включая список хуков. Каждый хук имеет свой **индекс в списке, основанный на порядке вызова** в функции компонента. Состояние хука сохраняется в соответствующем узле, и React использует индекс вызова, чтобы сопоставить хук с его состоянием

Хуки связываются с компонентом через узел в дереве рендеринга, где React хранит их состояния в списке по порядку вызова. Каждый компонент имеет свой список хуков, поэтому состояния не перемешиваются. Порядок вызовов критичен для правильного сопоставления