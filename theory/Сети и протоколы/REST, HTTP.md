### Что такое REST?

**REST** - это архитектурный **стиль** взаимодействия между клиентом и сервером через **HTTP**. Определяет принципы построения API

Каждый ресурс в REST API имеет уникальный идентификатор и управляется с помощью **методов HTTP**:
- **GET**: Получение данных
- **POST**: Создание ресурса 
- **PUT/PATCH**: Обновление ресурса
- **DELETE**: Удаление ресурса

**Основные принципы REST:**
1. **Клиент-серверная архитектура**: чёткое разделение между клиентом и сервером
2. **Без сохранения состояния:** каждый запрос от клиента к серверу обрабатывается независимо от предыдущих запросов, сервер не хранит информацию о состоянии клиента
3. **Кеширование**: ответы сервера могут кешироваться (HTTP-заголовки Cache-Control)
4. **Единообразие интерфейса**: ресурсы должны иметь **единообразные уникальные URL**-адреса, запросы к API выполняться с использованием стандартных методов HTTP, а данные передаваться в форматах JSON или XML
5. **Многослойная система**: REST API может включать несколько уровней (слоёв), каждый из которых не зависит от других (балансировщики нагрузки, прокси-серверы)
6. **Возможность выполнения кода по требованию:** REST API может поддерживать загрузку и выполнение кода на стороне клиента

- REST API интегрируется через fetch или axios

### Отличие GraphQL от REST API

В GraphQL все данные можно получить одним запросом из разных источников. А в REST API придётся сделать выборку и извлекать их уже оттуда.
```JSON
query getCheeseburger ($vegan: Boolean) {
  cheeseburger {
            bun
            patty
            pickle
            onion
            cheese @skip(if: $vegan)
  }
}
```

### Можно ли в GET положить тело запроса?

Технически в GET-запросе можно передать тело запроса, но не рекомендуется и противоречит стандартам REST и HTTP

В GET данные обычно передаются через **query параметры** (например, /api/books?filter=fiction)

### Что за HTTP-метод OPTIONS?

OPTIONS отправляет запрос к серверу, чтобы узнать, какие методы (GET, POST, PUT, DELETE и т.д.), заголовки (CORS-заголовки) или другие параметры разрешены для ресурса:
```HTTP
HTTP/1.1 200 OK
Allow: GET, POST, OPTIONS
Access-Control-Allow-Origin: *
Access-Control-Allow-Methods: GET, POST, PUT, DELETE
Access-Control-Allow-Headers: Content-Type, Authorization
```
Браузер инициирует предварительный запрос с методом OPTIONS, проверяет ответ сервера, анализируя CORS-заголовки, и если в зависимости от ответа либо отправляет основной запрос, либо блокирует его

Это регулируется **CORS** - политикой безопасности браузеров

### С точки зрения разных версий HTTP 1.1 и HTTP 2.0, что будет лучше, много маленьких бандлов (в webpack разбить на чанки) или один большой файл?

**HTTP/1.1:** Один большой бандл
Т.к. использует одно соединение на запрос. Запросы обрабатываются последовательно, и задержка одного запроса **блокирует** остальные. Последовательная загрузка маленьких бандлов может замедлить приложение, хоть и ускорится начальная загрузка

**HTTP/2.0:** Много маленьких бандлов
Поддерживает **мультиплексирование** - множество параллельных запросов, которые не блокируют друг друга + отдельные чанки **кэшируются** браузером