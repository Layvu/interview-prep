### Назначение и отличие типов any, unknown, never

**any:** отключает проверку типов, не безопасен
- Использовать временно или для неконтролируемых данных

**unknown:** безопасная альтернатива any, требует явной проверки типов (через if)
- Нельзя выполнять операции без проверки типа
- Для работы с данными, тип которых неизвестен на момент написания кода (данные с API, пропсы)

```JS
function Component({ data }: { data: unknown }) {
    if (typeof data === 'string') {
        return <div>{data.toUpperCase()}</div>;
    }
    return <div>No data</div>;
}
```

**never:** для значений, которых не существует, например, в функциях с ошибками или исчерпывающих проверках

- Для функций, которые всегда выбрасывают ошибку или бесконечно выполняются
- Для исчерпывающей проверки в switch или условных конструкциях
- Переменная типа never не может быть присвоена никаким значением

```JS
type Status = 'loading' | 'success' | 'error';
function StatusComponent({ status }: { status: Status }) {
    switch (status) {
        case 'loading': return <div>Loading...</div>;
        case 'success': return <div>Success!</div>;
        case 'error': return <div>Error!</div>;
        default:
            const _exhaustive: never = status; // Гарантирует, что все случаи обработаны
            throw new Error('Invalid status');
    }
}
```

### Дженерики с TS, зачем нужны, пример использования

**Дженерики `<T>`:** для создания универсальных компонентов, функций и классов, которые могут работать с разными типами данных, сохраняя строгую типизацию

**Примеры применения:**
- Функции, работающие с массивами разных типов
- Компоненты React, принимающие пропсы разных структур
- Хуки с динамическими типами возвращаемых данных

**Хук для загрузки данных** из API с динамическим типом ответа
```JS
function useFetch<T>(url: string): { data: T | null; loading: boolean; error: string | null } {
    const [data, setData] = useState<T | null>(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);
    useEffect(() => {
        async function fetchData() {
            try {
                const response = await fetch(url);
                const result = await response.json();
                setData(result);
            } catch (err) {
                setError((err as Error).message);
            } finally {
                setLoading(false);
            }
        }
        fetchData();
    }, [url]);
    return { data, loading, error };
}

// Использование
interface User {
    id: number;
    name: string;
}

function UserList() {
    const { data, loading, error } = useFetch<User[]>('https://api.example.com/users');
    if (loading) return <div>Loading...</div>;
    if (error) return <div>Error: {error}</div>;
    return <ul>{data?.map(user => <li key={user.id}>{user.name}</li>)}</ul>;
}
```